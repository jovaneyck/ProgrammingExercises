using System;
using System.Reflection;
using Ploeh.AutoFixture;
using Ploeh.AutoFixture.Kernel;
using Xunit;

namespace AutoFixture
{
    public class CustomObjectCreationShould
    {
        public class Country
        {
            private string _code;

            public string Code
            {
                get { return _code; }
                set
                {
                    ValidateCountryCode(value);
                    _code = value;
                }
            }

            private static void ValidateCountryCode(string value)
            {
                if (value.ToUpper() != value || value.Length > 3)
                {
                    throw new ArgumentException("must be a valid country code", "value");
                }
            }
        }

        [Fact]
        public void ViolateClassInvariantsWithDefaultTypeGeneration()
        {
            var fixture = new Fixture();

            Assert.Throws<TargetInvocationException>(() => 
                fixture.Create<Country>()); 
            //blows up since invariant of country code is violated by Autofixture's default string values.
        }

        [Fact]
        public void AllowForInjectingFlyweightObjects()
        {
            var fixture = new Fixture();

            fixture.Inject("BEL"); //All autogenerated strings now have this value.

            Assert.Equal("BEL", fixture.Create<Country>().Code);
        }
        
        [Fact]
        public void AllowForInjectingFlyweightObjectsOfAnyType()
        {
            var fixture = new Fixture();
            var country = new Country {Code = "FR"};
            fixture.Inject(country); //All autogenerated countries now have this value.

            Assert.Equal(country, fixture.Create<Country>());
        }

        [Fact]
        public void SkipSettingCertainProperties()
        {
            var fixture = new Fixture();
            var country = fixture //Free test data builders, such wow, much awesome!
                .Build<Country>()
                .Without(c=>c.Code)
                .Create();

            Assert.Null(country.Code);
        }

        [Fact]
        public void BuildWithSpecificValuesForCertainProperties()
        {
            var fixture = new Fixture();

            var country = fixture
                .Build<Country>()
                .With(c => c.Code, "FR")
                .Create();

            Assert.Equal("FR", country.Code);
        }

        class Foo
        {
            public bool Initialized { get; private set; }

            public void Initialize()
            {
                Initialized = true;
            }
        }

        [Fact]
        public void ProvideHooksInTheBuildingProcess()
        {
            var fixture = new Fixture();
            var foo = fixture
                .Build<Foo>()
                .Do(f=>f.Initialize()) //Can do all sorts of stuff on the object while being created...
                .Create();

            Assert.True(foo.Initialized);
        }

        //Things are getting hardcore here...
        class AlwaysAbcCountrySpecimenBuilder : ISpecimenBuilder
        {
            public object Create(object request, ISpecimenContext context)
            {
                var propertyInfo = request as PropertyInfo;
                if (propertyInfo == null)
                {
                    return new NoSpecimen(request); //Null Object pattern!
                }

                if (propertyInfo.PropertyType == typeof (string) && propertyInfo.Name == "Code")
                {
                    return "ABC";
                }

                return new NoSpecimen(request);
            }
        }

        [Fact]
        public void AcceptCustomizations()
        {
            var fixture = new Fixture();
            fixture.Customizations.Add(new AlwaysAbcCountrySpecimenBuilder());

            var country = fixture.Create<Country>();

            Assert.Equal("ABC", country.Code);
        }
    }
}