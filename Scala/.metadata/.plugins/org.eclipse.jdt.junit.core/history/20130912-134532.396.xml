<?xml version="1.0" encoding="UTF-8"?>
<testrun name="All tests" project="LanguageFeatures" tests="40" started="40" failures="0" errors="0" ignored="0">
  <testsuite name="test.Lists" time="0.139">
    <testcase name="lists should have an empty list concept" classname="test.Lists" time="0.049"/>
    <testcase name="lists should have a cons concept" classname="test.Lists" time="0.001"/>
    <testcase name="lists should have a friendly notation" classname="test.Lists" time="0.001"/>
    <testcase name="lists should support the map function" classname="test.Lists" time="0.003"/>
    <testcase name="lists should support the flatMap function" classname="test.Lists" time="0.003"/>
    <testcase name="lists should support filtering" classname="test.Lists" time="0.003"/>
    <testcase name="lists should support a fold" classname="test.Lists" time="0.008"/>
    <testcase name="lists should support a reduce" classname="test.Lists" time="0.005"/>
    <testcase name="lists should be easy to combine lists" classname="test.Lists" time="0.003"/>
    <testcase name="lists should support an easy for all check" classname="test.Lists" time="0.006"/>
    <testcase name="lists should support easy grouping" classname="test.Lists" time="0.004"/>
    <testcase name="lists should support easy sorting" classname="test.Lists" time="0.005"/>
    <testcase name="lists should support arbitrary sorting" classname="test.Lists" time="0.004"/>
    <testcase name="lists should allow easy updates" classname="test.Lists" time="0.044"/>
  </testsuite>
  <testsuite name="test.Streams" time="0.01">
    <testcase name="streams should represent an infinite list" classname="test.Streams" time="0.006"/>
    <testcase name="streams should be possible to create an infinite stream with complex values" classname="test.Streams" time="0.004"/>
  </testsuite>
  <testsuite name="test.Recursion" time="0.003">
    <testcase name="recursion should end" classname="test.Recursion" time="0.001"/>
    <testcase name="recursion should support tail recursion" classname="test.Recursion" time="0.002"/>
  </testsuite>
  <testsuite name="test.ClassesAndObjects" time="0.034">
    <testcase name="classes should have properties" classname="test.ClassesAndObjects" time="0.001"/>
    <testcase name="classes should support read-only attributes" classname="test.ClassesAndObjects" time="0.001"/>
    <testcase name="classes should support mutable state" classname="test.ClassesAndObjects" time="0.006"/>
    <testcase name="classes should support private methods" classname="test.ClassesAndObjects" time="0.001"/>
    <testcase name="classes should support invariants and preconditions" classname="test.ClassesAndObjects" time="0.005"/>
    <testcase name="classes should support post-condition checking" classname="test.ClassesAndObjects" time="0.01"/>
    <testcase name="case classes should not require the new keyword, handy for pattern matching!" classname="test.ClassesAndObjects" time="0.004"/>
    <testcase name="objects should act as a singleton" classname="test.ClassesAndObjects" time="0.002"/>
    <testcase name="companion objects should act as a factory for classes" classname="test.ClassesAndObjects" time="0.004"/>
  </testsuite>
  <testsuite name="test.DesignPatterns" time="0.016">
    <testcase name="visitor should be easily implemented using pattern matching" classname="test.DesignPatterns" time="0.005"/>
    <testcase name="singleton should be implemented by an object" classname="test.DesignPatterns" time="0.003"/>
    <testcase name="factory method should be implemented with companion objects to avoid cluttering the namespace" classname="test.DesignPatterns" time="0.003"/>
    <testcase name="template method should be clear that functional programming was MADE for easy function composition" classname="test.DesignPatterns" time="0.005"/>
  </testsuite>
  <testsuite name="test.Traits" time="0.017">
    <testcase name="traits should act as an interface that can have an implementation" classname="test.Traits" time="0.004"/>
    <testcase name="traits should support multiple inheritance" classname="test.Traits" time="0.006"/>
    <testcase name="traits should have no problems with the 'diamond problem'" classname="test.Traits" time="0.007"/>
  </testsuite>
  <testsuite name="test.ForComprehensions" time="0.012">
    <testcase name="for comprehensions should iterate over sequentials" classname="test.ForComprehensions" time="0.003"/>
    <testcase name="for comprehensions should iterate faster over later generators" classname="test.ForComprehensions" time="0.005"/>
    <testcase name="for comprehensions should allow for easy filtering" classname="test.ForComprehensions" time="0.004"/>
  </testsuite>
  <testsuite name="test.PatternMatching" time="0.005">
    <testcase name="pattern matching, you could see this as 'unpacking' objects should work on case classes" classname="test.PatternMatching" time="0.001"/>
    <testcase name="pattern matching, you could see this as 'unpacking' objects should be possible to use matching to unpack data structures" classname="test.PatternMatching" time="0.003"/>
    <testcase name="pattern matching, you could see this as 'unpacking' objects should support wildcards" classname="test.PatternMatching" time="0.001"/>
  </testsuite>
</testrun>
